#!/usr/bin/env node

/**
 * å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªè„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒŠãƒ¼
 * npm auditãƒ»Snykãƒ»æ‰‹å‹•ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãƒã‚§ãƒƒã‚¯
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const chalk = require('chalk');

// æ—¢çŸ¥ã®è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
const VULNERABILITY_DB = {
  'lodash': [
    {
      versions: '<4.17.21',
      severity: 'high',
      cve: 'CVE-2021-23337',
      description: 'Prototype Pollution in lodash',
      fix: 'Upgrade to lodash@4.17.21 or later'
    }
  ],
  'axios': [
    {
      versions: '<0.21.2',
      severity: 'medium',
      cve: 'CVE-2021-3749',
      description: 'SSRF vulnerability in axios',
      fix: 'Upgrade to axios@0.21.2 or later'
    }
  ],
  'moment': [
    {
      versions: '<2.29.4',
      severity: 'medium',
      cve: 'CVE-2022-31129',
      description: 'ReDoS vulnerability in moment.js',
      fix: 'Upgrade to moment@2.29.4 or later'
    }
  ],
  'react-scripts': [
    {
      versions: '<5.0.1',
      severity: 'medium',
      cve: 'Multiple',
      description: 'Various vulnerabilities in bundled dependencies',
      fix: 'Upgrade to react-scripts@5.0.1 or later'
    }
  ],
  '@supabase/supabase-js': [
    {
      versions: '<2.38.0',
      severity: 'low',
      cve: 'GHSA-example',
      description: 'Authentication bypass in older versions',
      fix: 'Upgrade to @supabase/supabase-js@2.38.0 or later'
    }
  ],
  'styled-components': [
    {
      versions: '<5.3.11',
      severity: 'low',
      cve: 'CVE-2023-37466',
      description: 'XSS vulnerability in styled-components',
      fix: 'Upgrade to styled-components@5.3.11 or later'
    }
  ]
};

// å±é™ºãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ï¼ˆä½¿ç”¨éæ¨å¥¨ï¼‰
const DANGEROUS_PACKAGES = [
  {
    name: 'eval',
    reason: 'Executes arbitrary JavaScript code',
    alternatives: ['Safe parsing libraries']
  },
  {
    name: 'serialize-javascript',
    reason: 'Can lead to XSS if not used carefully',
    alternatives: ['JSON.stringify with proper validation']
  },
  {
    name: 'node-uuid',
    reason: 'Deprecated, use uuid instead',
    alternatives: ['uuid']
  }
];

class VulnerabilityScanner {
  constructor() {
    this.vulnerabilities = [];
    this.dependencies = new Map();
  }

  async scanProject() {
    console.log(chalk.blue('\nğŸ” Starting Vulnerability Scan\n'));

    await this.loadDependencies();
    await this.runNpmAudit();
    await this.checkVulnerabilityDatabase();
    await this.checkDangerousPackages();
    await this.checkOutdatedPackages();
    await this.generateReport();
  }

  async loadDependencies() {
    console.log('ğŸ“¦ Loading dependencies...');

    const packagePaths = [
      'app/package.json',
      'package.json'
    ];

    for (const packagePath of packagePaths) {
      if (fs.existsSync(packagePath)) {
        try {
          const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
          const allDeps = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
          };

          Object.entries(allDeps).forEach(([name, version]) => {
            this.dependencies.set(name, {
              version: version,
              file: packagePath,
              isDev: packageJson.devDependencies?.[name] ? true : false
            });
          });

          console.log(`  Found ${Object.keys(allDeps).length} dependencies in ${packagePath}`);
        } catch (error) {
          console.error(`Error reading ${packagePath}:`, error.message);
        }
      }
    }

    console.log(`Total dependencies: ${this.dependencies.size}\n`);
  }

  async runNpmAudit() {
    console.log('ğŸ” Running npm audit...');

    try {
      const result = execSync('npm audit --json --prefix=app', { 
        encoding: 'utf8',
        timeout: 30000 
      });
      
      const auditData = JSON.parse(result);
      
      if (auditData.vulnerabilities) {
        Object.entries(auditData.vulnerabilities).forEach(([name, vuln]) => {
          this.vulnerabilities.push({
            source: 'npm-audit',
            package: name,
            severity: vuln.severity,
            title: vuln.title || 'Unknown vulnerability',
            description: vuln.url || 'No description available',
            versions: vuln.range || 'Unknown',
            fix: vuln.fixAvailable ? 'Update available' : 'No fix available'
          });
        });
      }

      console.log(`  Found ${Object.keys(auditData.vulnerabilities || {}).length} vulnerabilities from npm audit\n`);
    } catch (error) {
      console.log(chalk.yellow('  npm audit failed or no vulnerabilities found\n'));
    }
  }

  async checkVulnerabilityDatabase() {
    console.log('ğŸ—ƒï¸  Checking vulnerability database...');

    let foundVulns = 0;

    this.dependencies.forEach((depInfo, name) => {
      const vulns = VULNERABILITY_DB[name];
      if (vulns) {
        vulns.forEach(vuln => {
          if (this.isVersionVulnerable(depInfo.version, vuln.versions)) {
            this.vulnerabilities.push({
              source: 'internal-db',
              package: name,
              severity: vuln.severity,
              title: vuln.cve,
              description: vuln.description,
              versions: vuln.versions,
              fix: vuln.fix,
              currentVersion: depInfo.version
            });
            foundVulns++;
          }
        });
      }
    });

    console.log(`  Found ${foundVulns} vulnerabilities from internal database\n`);
  }

  async checkDangerousPackages() {
    console.log('âš ï¸  Checking for dangerous packages...');

    let foundDangerous = 0;

    this.dependencies.forEach((depInfo, name) => {
      const dangerous = DANGEROUS_PACKAGES.find(pkg => pkg.name === name);
      if (dangerous) {
        this.vulnerabilities.push({
          source: 'dangerous-package',
          package: name,
          severity: 'medium',
          title: 'Dangerous Package',
          description: dangerous.reason,
          versions: 'all',
          fix: `Consider alternatives: ${dangerous.alternatives.join(', ')}`,
          currentVersion: depInfo.version
        });
        foundDangerous++;
      }
    });

    console.log(`  Found ${foundDangerous} dangerous packages\n`);
  }

  async checkOutdatedPackages() {
    console.log('ğŸ“… Checking for outdated packages...');

    try {
      const result = execSync('npm outdated --json --prefix=app', { 
        encoding: 'utf8',
        timeout: 30000 
      });
      
      const outdatedData = JSON.parse(result);
      let outdatedCount = 0;

      Object.entries(outdatedData).forEach(([name, info]) => {
        // ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå¤ã„å ´åˆã¯è­¦å‘Š
        const currentMajor = this.getMajorVersion(info.current);
        const latestMajor = this.getMajorVersion(info.latest);

        if (latestMajor > currentMajor) {
          this.vulnerabilities.push({
            source: 'outdated',
            package: name,
            severity: 'low',
            title: 'Outdated Package',
            description: `Major version behind (${info.current} -> ${info.latest})`,
            versions: info.current,
            fix: `Update to ${info.latest}`,
            currentVersion: info.current
          });
          outdatedCount++;
        }
      });

      console.log(`  Found ${outdatedCount} significantly outdated packages\n`);
    } catch (error) {
      console.log(chalk.yellow('  npm outdated failed or no outdated packages\n'));
    }
  }

  isVersionVulnerable(currentVersion, vulnerableRange) {
    // ç°¡å˜ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆå®Ÿéš›ã«ã¯semverãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨æ¨å¥¨ï¼‰
    const cleanCurrent = currentVersion.replace(/[^0-9.]/g, '');
    const cleanRange = vulnerableRange.replace(/[^0-9.<>=]/g, '');

    if (vulnerableRange.startsWith('<')) {
      const targetVersion = cleanRange;
      return this.compareVersions(cleanCurrent, targetVersion) < 0;
    }

    return false;
  }

  compareVersions(version1, version2) {
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);

    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
      const v1Part = v1Parts[i] || 0;
      const v2Part = v2Parts[i] || 0;

      if (v1Part < v2Part) return -1;
      if (v1Part > v2Part) return 1;
    }

    return 0;
  }

  getMajorVersion(version) {
    return parseInt(version.split('.')[0] || '0');
  }

  async generateReport() {
    console.log(chalk.blue('\nğŸ“Š Vulnerability Report\n'));

    const severityCounts = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };

    // ã‚«ã‚¦ãƒ³ãƒˆ
    this.vulnerabilities.forEach(vuln => {
      severityCounts[vuln.severity] = (severityCounts[vuln.severity] || 0) + 1;
    });

    // ã‚µãƒãƒªãƒ¼è¡¨ç¤º
    console.log('Vulnerability Summary:');
    console.log(chalk.red(`ğŸ”´ Critical: ${severityCounts.critical}`));
    console.log(chalk.red(`ğŸ”´ High: ${severityCounts.high}`));
    console.log(chalk.yellow(`ğŸŸ¡ Medium: ${severityCounts.medium}`));
    console.log(chalk.blue(`ğŸ”µ Low: ${severityCounts.low}`));
    console.log(`\nTotal Vulnerabilities: ${this.vulnerabilities.length}\n`);

    // è©³ç´°è¡¨ç¤º
    if (this.vulnerabilities.length > 0) {
      console.log('Detailed Findings:\n');

      // é‡è¦åº¦ã§ã‚½ãƒ¼ãƒˆ
      const sortedVulns = this.vulnerabilities.sort((a, b) => {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        return severityOrder[b.severity] - severityOrder[a.severity];
      });

      sortedVulns.forEach((vuln, index) => {
        const severityColor = vuln.severity === 'critical' || vuln.severity === 'high' ? chalk.red :
                             vuln.severity === 'medium' ? chalk.yellow : chalk.blue;
        
        console.log(`${index + 1}. ${severityColor(vuln.title)} (${vuln.severity.toUpperCase()})`);
        console.log(`   Package: ${vuln.package}${vuln.currentVersion ? `@${vuln.currentVersion}` : ''}`);
        console.log(`   Description: ${vuln.description}`);
        console.log(`   Fix: ${vuln.fix}`);
        console.log(`   Source: ${vuln.source}\n`);
      });
    }

    // æ¨å¥¨äº‹é …
    console.log(chalk.blue('ğŸ› ï¸  Security Recommendations:\n'));
    
    const recommendations = [
      '1. Run npm audit fix to automatically fix vulnerabilities',
      '2. Update outdated packages with npm update',
      '3. Remove unused dependencies with npm uninstall',
      '4. Use npm ci in production for consistent installs',
      '5. Enable GitHub security alerts for your repository',
      '6. Consider using Renovate or Dependabot for automated updates',
      '7. Regularly review and audit dependencies',
      '8. Use package-lock.json to lock dependency versions',
      '9. Monitor security advisories for critical packages',
      '10. Implement security policies in CI/CD pipeline'
    ];

    recommendations.forEach(rec => console.log(chalk.green(rec)));

    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢
    const score = Math.max(0, 100 - (
      severityCounts.critical * 20 +
      severityCounts.high * 10 +
      severityCounts.medium * 5 +
      severityCounts.low * 1
    ));

    console.log(chalk.blue(`\nğŸ”’ Security Score: ${Math.round(score)}/100\n`));

    if (score >= 90) {
      console.log(chalk.green('ğŸ‰ Excellent dependency security!'));
    } else if (score >= 70) {
      console.log(chalk.yellow('âš ï¸  Good security, minor issues to address'));
    } else if (score >= 50) {
      console.log(chalk.yellow('ğŸ”¶ Moderate security concerns'));
    } else {
      console.log(chalk.red('ğŸš¨ Critical security issues require immediate attention!'));
    }

    // JSON ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalVulnerabilities: this.vulnerabilities.length,
        severityCounts,
        securityScore: Math.round(score)
      },
      dependencies: Object.fromEntries(this.dependencies),
      vulnerabilities: this.vulnerabilities,
      recommendations
    };

    fs.writeFileSync('vulnerability-report.json', JSON.stringify(report, null, 2));
    console.log(chalk.blue('\nğŸ“„ Detailed report saved to vulnerability-report.json'));

    return report;
  }
}

// ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
async function main() {
  console.log(chalk.bold.green('\nğŸ›¡ï¸  Dependency Vulnerability Scanner\n'));

  const scanner = new VulnerabilityScanner();
  const report = await scanner.scanProject();

  // çµ‚äº†ã‚³ãƒ¼ãƒ‰
  const exitCode = report.summary.severityCounts.critical > 0 ? 1 : 0;
  process.exit(exitCode);
}

if (require.main === module) {
  main().catch(error => {
    console.error(chalk.red('Scanner failed:'), error);
    process.exit(1);
  });
}

module.exports = { VulnerabilityScanner };